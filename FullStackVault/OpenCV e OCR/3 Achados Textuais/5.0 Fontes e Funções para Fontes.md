[[OpenCV]]Estudamos e fizemos algumas modificações com as fontes. No vídeo anterior, utilizamos a `FONT_HERSHEY_SIMPLEX` e podemos, inclusive, alterá-la. Também fizemos o _bounding box_ na imagem de cópia, enfim, conseguimos fazer uma utilização delas. Porém, quando estávamos escolhendo uma das fontes para colocá-la dentro do OpenCV, percebemos que não existiam muitas.

Outra limitação é: quando colocamos uma fonte do OpenCV junto a um caractere especial, ele retorna símbolos que não são identificáveis, ou seja, não sabe reconhecer caracteres especiais. Para isso, precisamos utilizar fontes externas, por exemplo, Arial ou Calibri. Sendo assim, nosso próximo passo é aprender a colocar fontes externas no nosso projeto e inseri-las dentro de uma imagem.

A imagem que usaremos será diferente da que foi usada na aula anterior, mas, é uma imagem que utilizamos na aula 1. Vamos conferir como o OSD reage, primeiro, com a troca de imagem e, segundo, com uma imagem já usada no processo. A importação será do mesmo tipo que fizemos anteriormente, no início da aula 3. A imagem é "Aula1-ocr.png". Vamos copiar o caminho e substituir no código.

```makefile
img = cv2.imread('/content/text-recognize/Imagens/Aula1-ocr.png')
rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
cv2_imshow(rgb)
```

![Logo do Google, "G" maiúsculo, preenchido por quatro cores. A primeira partição é azul escuro. A segunda partição é azul turquesa. A terceira partição é verde. A quarta e última partição é laranja. Abaixo do logo, está escrito "Tesseract OCR" em cinza claro. O fundo da imagem é marrom](https://cdn1.gnarususercontent.com.br/1/563691/6b2acb2d-e97e-42d3-a038-a4bad5b088d6.png)

Também geraremos o resultado com `output_type=Output.DICT`. Além disso, vamos conferir como ele está se saindo agora que já fizemos algumas mudanças no nosso código. Então, faremos uma configuração mais apurada do `tessdata`, além disso, configuraremos a linguagem para português e o `Output.DICT`.

```lua
config_tesseract = '--tessdata-dir tessdata'
resultado = pytesseract.image_to_data(rgb, config=config_tesseract, lang='por', output_type=Output.DICT)
resultado
```

O resultado, é:
![[Pasted image 20230307164035.png]]
Ele encontrou os números de confiança: 91, 91 e 90. Também encontrou os textos "G", portanto reconheceu o logo do Google, "Tesseract" e "OCR". O nosso OCR melhorou consideravelmente apenas com algumas técnicas, mas, saindo um pouco do campo da imagem, vamos chamar novamente a biblioteca **PIL**. Nós utilizamos a PIL na manipulação de imagem em vídeos anteriores. Agora, usaremos para colocar uma nova fonte no nosso projeto.

Nós importaremos três módulos, então, `from PIL import ImageFont, ImageDraw, Image`. Na linha abaixo, indicaremos o nome da fonte que vamos usar. O caminho já está pronto no nosso GitHub, "calibri.ttf", basta copiar e colar em uma nova variável.

```java
from PIL import ImageFont, ImageDraw, Image

fonte = '/content/text-recognize/Imagens/calibri.ttf'
```

Rodamos a célula e agora já temos a fonte dentro do projeto. Para utilizá-la, faremos uma função e a colocaremos no lugar da fonte que estávamos usando, a `FONT_HERSHEY_SIMPLEX`. Ao invés dessa fonte, utilizaremos a Calibri. Faremos isso na próxima aula!!

Já importamos a fonte _Calibri_ para o nosso projeto e podemos começar a construir uma nova função chamada `escreve_texto`.

```scss
def escreve_texto(texto, x, y, img, fonte, tamanho_texto=32):
  fonte = ImageFont.truetype(fonte, tamanho_texto)
  img_pil = Image.fromarray(img)
  draw = ImageDraw.Draw(img_pil)
  draw.text((x, y - tamanho_texto), texto, font = fonte)
  img = np.array(img_pil)
  return img
```

Vamos analisá-la passo a passo! Começaremos definindo`def escreve_texto()`. Primeiro, passaremos o texto que estamos recebendo, `texto`, e que vem da função `for`:

```go
img_copia = rgb.copy()
for i in range(len(resultado['text'])):
  confianca = int(resultado['conf'][i])
  if confianca > min_conf:
    x, y, img = caixa_texto(resultado, img_copia)

    texto = resultado['text'][i]
    cv2.putText(img_copia, texto, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,100,255))

cv2_imshow(img_copia)
```

Depois, passaremos: `x` e `y`, que se referem às posições; a imagem, `img`; a `fonte`, que será a Calibri; e o tamanho do texto que, por enquanto, será 32, `tamanho_texto=32`, mas, a depender da imagem ou de sua disposição, podemos diminuir ou aumentar o tamanho.

Na próxima linha, definiremos a `fonte`, que será igual a `ImageFont`, e que vem do módulo `PIL`:

```java
from PIL import ImageFont, ImageDraw, Image

fonte = '/content/text-recognize/Imagens/calibri.ttf'
```

Seguindo, escreveremos `truetype()`, passaremos a `fonte` e o `tamanho_texto`. Na próxima linha, faremos `img_pil`, isto é, a imagem PIL, igual a `Image.fromarray()`, passando a imagem, `img`. Com isso, transformaremos uma imagem em _array_ para PIL.

```scss
def escreve_texto(texto, x, y, img, fonte, tamanho_texto=32):
  fonte = ImageFont.truetype(fonte, tamanho_texto)
  img_pil = Image.fromarray(img)
```

Em seguida, faremos o desenho da nossa escrita. Lembrando que, anteriormente, começamos pelo desenho da caixa, _bounding box_, e depois fizemos o texto. Desta vez, começamos com a `img_PIL` e depois passamos para o desenho das fontes, `draw = ImageDraw.Draw(img_pil)`. Então, estamos fazendo o desenho, `ImageDraw.Draw()`. Essa etapa nos permitirá desenhar na `img_pil`, que é a imagem transformada em PIL.

Na próxima linha, faremos um `draw.text()` no `x,y`, menos o tamanho do texto, `tamanho_texto`, que será 32. Depois, `texto` e `font = fonte`. Esses são os parâmetros que passamos para o `draw.text`, eles farão o desenho do nosso texto. Por fim, passamos outra vez `img = np.array(img_pil)`.

```scss
def escreve_texto(texto, x, y, img, fonte, tamanho_texto=32):
  fonte = ImageFont.truetype(fonte, tamanho_texto)
  img_pil = Image.fromarray(img)
  draw = ImageDraw.Draw(img_pil)
```

Basicamente, passamos a imagem como um _array_, ele transformou em PIL e escreveu o texto com a fonte Calibri. Depois disso, pegamos a imagem, em PIL, e transformamos para _array_ de novo, assim ela poderá ser utilizada no OpenCV. O processo é um pouco demorado e custoso, mas fontes externas, como a Calibri, nos permitem escrever termos de caracteres especiais, o que não é possível com as fontes que são originalmente do OpenCV.

Agora, vamos rodar a função!

```scss
def escreve_texto(texto, x, y, img, fonte, tamanho_texto=32):
  fonte = ImageFont.truetype(fonte, tamanho_texto)
  img_pil = Image.fromarray(img)
  draw = ImageDraw.Draw(img_pil)
  draw.text((x, y - tamanho_texto), texto, font = fonte)
  img = np.array(img_pil)
  return img
```

A próxima etapa é copiar a função `caixa_texto` que fizemos anteriormente e colar na célula abaixo. Além disso, vamos comentar o `#cv2.putText()` e adicionar uma nova linha para escrevermos o texto:

```ini
img_copia = escreve_texto(texto, x, y, img_copia, fonte)
```

Então, depois do texto, queremos que ele faça um `img_copia` igual a `escreve_texto()`, função que acabamos de criar, passando `texto`, `x` e `y`, a imagem de cópia, `img_copia`, e a `fonte`. Vamos rodar e conferir o que ele vai retornar.

```go
img_copia = rgb.copy()
for i in range(len(resultado['text'])):
  confianca = int(resultado['conf'][i])
  if confianca > min_conf:
    x, y, img = caixa_texto(resultado, img_copia)

    texto = resultado['text'][i]
    #cv2.putText(img_copia, texto, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,100,255))
    img_copia = escreve_texto(texto, x, y, img_copia, fonte)

cv2_imshow(img_copia)
```

Ele retornou uma imagem que já conhecemos, com o logo do Google, "G" maiúsculo e, abaixo, a frase "Tesseract OCR".

![Logo do Google, "G" maiúsculo, preenchido por quatro cores. A primeira partição é azul escuro. A segunda partição é azul turquesa. A terceira partição é verde. A quarta e última partição é laranja. Abaixo do logo, está escrito "Tesseract OCR" em cinza claro. O logo e as duas palavras estão envoltas por uma moldura azul clara, *bounding box*. Acima das molduras, está escrito em branco, respectivamente: G; Tesseract; e OCR. O fundo da imagem é marrom.](https://cdn1.gnarususercontent.com.br/1/563691/825d22da-530f-47f4-9af5-a49aa358c690.png)

A fonte Calibri que escolhemos para a escrita do texto é um pouco mais arredondada que a utilizada anteriormente, do OpenCV, e até mais simples de ser lida, por já estarmos habituados. Além disso, as letras têm cor branca e isso ajuda na visibilidade do texto. Nós não temos nenhum caractere especial, mas, nestes casos, é bastante recomendável a utilização de fontes externas.

Concluímos duas tarefas importantes: colocar _bounding box_ e adicionar fontes externas. Nos encontramos na próxima aula para outros desafios!
